<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Bare - Start Bootstrap Template</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
	
	<!-- Custom styles for this template -->
    <link href="css/simple-sidebar.css" rel="stylesheet">
	
	<!-- Prism Code Stylesheet -->
	<link href="prism/prism.css" rel="stylesheet" />
	
	<!-- Custom styles -->
    <link href="css/custom.css" rel="stylesheet">

  </head>

  <body>

    <!-- Navigation -->
    <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark static-top">
      <div class="container">
        <a class="navbar-brand" href="index.html">Algorithm Site</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="about.html">About</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="contact.html">Contact</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
	
	<div id="wrapper" class="toggled">

        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li>
                    <a href="sorting.html">Sorting</a>
                </li>
                <li>
                    <a href="hashtables.html">Hash Tables</a>
                </li>
                <li>
                    <a href="trees.html">Trees</a>
                </li>
                <li>
                    <a href="graphs.html">Graphs</a>
                </li>
                <li>
                    <a href="other.html">Other Algorithms</a>
                </li>
                <li>
                    <a href="mathematics.html">Mathematics</a>
                </li>
                <li>
                    <a href="operatingsystems.html">Operating Systems</a>
                </li>
            </ul>
        </div>
        <!-- /#sidebar-wrapper -->

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid">
                <div class="jumbotron text-center">
					<h1 class="display-2"><b>Trees</b></h1>
					<p>
					This page will go over a series of Tree Algorithms. Concepts discussed will be tree construction, tree traversal, and types of trees. Types of trees
					include Binary Trees, N-ary Trees, Tri-Trees, and Red/Black Trees which are balanced binary trees. Inorder, postorder, and preorder will also be addressed
					</p>
				</div>
            </div>

			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Types of Trees</h1>
				  <p class="lead">This section will show implementations of Binary Trees, N-ary Trees, Tri-Trees, and Red/Black Trees. 				  
				  </p>
				</div>
			  </div>
			</div>
			
			<br />
		
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Binary Trees</h1>
				  <p class="lead">Binary Trees are trees where each node has at most 2 children. A full binary tree is a binary tree where every node has either 0 or 2 children.
				  A Complete binary tree is a tree with all levels filled except the last row, which can still be filled but doesn't have to be, and all nodes are as left as
				  possible in the tree. A binary tree is said to be perfect is all all nodes not on the last level have 2 children and all leaves are on the same level. Finally,
				  a binary tree is balanced if a tree with N nodes has a height of O(Log(N)). A Binary Tree implementation is shown below.
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Binary Tree Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

public class Node&ltT&gt
{
    public T data;
    public Node&ltT&gt left;
    public Node&ltT&gt right;

    public Node(T data)
    {
        this.data = data;
        left = null;
        right = null;
    }
}

public class BinaryTree&ltT&gt
{
    public Node&ltT&gt root;

    public BinaryTree()
    {
        root = null;
    }

    public BinaryTree(T data)
    {
        root = new Node&ltT&gt(data);
    }
}

public class BinaryTreeTest
{
    public static void Main(string[] args)
    {
        int data = 10;
        BinaryTree&ltint&gt tree = new BinaryTree&ltint&gt(data);
        tree.root.left = new Node&ltint&gt(1);
        tree.root.right = new Node&ltint&gt(2);
        tree.root.left.left = new Node&ltint&gt(5);
        tree.root.left.right = new Node&ltint&gt(3);
        tree.root.right = new Node&ltint&gt(4);
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>N-ary Trees</h1>
				  <p class="lead">N-ary Trees are similar to Binary Trees except that each node can have any number of children. A very simple Nary-Tree implementation is below.
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>N-ary Tree Implementation Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

public class Node&ltT&gt
{
    public T data;
    public List&ltNode&ltT&gt&gt nodes = new List&ltNode&ltT&gt&gt();

    public Node(T data)
    {
        this.data = data;
    }
}

public class Tree&ltT&gt
{
    public Node&ltT&gt root;

    public Tree(T data)
    {
        root = new Node&ltT&gt(data);
    }
}

public class TestTree
{
    public static void Main(string[] args)
    {
        Tree&ltint&gt tree = new Tree&ltint&gt(10);
        tree.root.nodes.Add(new Node&ltint&gt(3));
        tree.root.nodes.Add(new Node&ltint&gt(4));
        tree.root.nodes.Add(new Node&ltint&gt(10));
        tree.root.nodes.Add(new Node&ltint&gt(7));
        tree.root.nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[1].nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[2].nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[3].nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[3].nodes[0].nodes.Add(new Node&ltint&gt(1));
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />

			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>AVL Tree</h1>
				  <p class="lead">
				  AVL Tree is a data structure where the height of the tree is O(Log(N)) through balancing. Keeping the tree balanced allows us to perform O(Log(N)) time lookups with binary search.
				  Functions such as search, delete, min, max can be added easily with guarenteed fast performance.
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>AVL Tree Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections;
using System.Collections.Generic;

public class Node
{
    public int data;
    public int height;
    public Node left;
    public Node right;

    public Node(int data)
    {
        this.data = data;
        height = 1;
    }
}

public class AVLTree
{

    public Node root;

    public AVLTree()
    {
        root = null;
    }

    public void Insert(int data)
    {
        if (root == null)
        {
            root = new Node(data);
            return;
        }

        root = Insert(root, data);
    }

    private Node Insert(Node node, int data)
    {
        //Perform standard BST Insert
        if (node == null)
        {
            return new Node(data);
        }

        if (data &lt node.data)
        {
            node.left = Insert(node.left, data);
        }
        else if (data &gt node.data)
        {
            node.right = Insert(node.right, data);
        }
        else
        {
            //Cannot insert a duplicate key
            return node;
        }

        //Set this node's height to be the height of the larger subtree + 1
        node.height = Math.Max(Height(node.left), Height(node.right)) + 1;

        //Find the first unbalanced node
        int balance = Balance(node);

        //Need to rebalance the tree        
        if (balance &gt 1 && node.left != null && data &lt node.left.data)
        {
            //left left insert
            return rightRotate(node);
        }
        else if (balance &gt 1 && node.left != null && data &gt node.left.data)
        {
            //left right insert
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }
        else if (balance &lt -1 && node.right != null && data &gt node.right.data)
        {
            //right right insert
            return leftRotate(node);
        }
        else if (balance &lt -1 && node.right != null && data &lt node.right.data)
        {
            //right left insert
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        return node;
    }

    //Rotate Node down a level to the node to its left
    public Node rightRotate(Node node)
    {
        Node pivot = node.left;
        Node rightNode = pivot.right;

        //Rotate
        pivot.right = node;
        node.left = rightNode;

        //Set height values
        node.height = Math.Max(Height(node.left), Height(node.right)) + 1;
        pivot.height = Math.Max(Height(pivot.left), Height(pivot.right)) + 1;

        return pivot;
    }

    //Rotate Node down a level to the node to its rigth
    public Node leftRotate(Node node)
    {
        Node pivot = node.right;
        Node leftNode = pivot.left;

        //Rotate
        pivot.left = node;
        node.right = leftNode;

        //Set height values
        node.height = Math.Max(Height(node.left), Height(node.right)) + 1;
        pivot.height = Math.Max(Height(pivot.left), Height(pivot.right)) + 1;

        return pivot;
    }

    public int Height(Node node)
    {
        if (node == null)
        {
            return 0;
        }
        else
        {
            return node.height;
        }
    }

    //Returns how unbalanced the node's branches are
    public int Balance(Node node)
    {
        return Height(node.left) - Height(node.right);
    }

    public void PrintTree()
    {
        //Use Breadth First Search to Print Tree        
        Queue queue = new Queue();
        queue.Enqueue(root);

        //Second queue used to print level
        Queue levelQueue = new Queue();
        queue.Enqueue(0);

        int previousLevel = 0;
        while (queue.Count != 0)
        {
            Node node = (Node)queue.Dequeue();
            int level = (int)queue.Dequeue();

            if (level == previousLevel)
            {
                Console.Write(node.data + ", ");
            }
            else
            {
                previousLevel += 1;
                Console.WriteLine("");
                Console.Write(node.data + ", ");
            }

            if (node.left != null)
            {
                queue.Enqueue(node.left);
                queue.Enqueue(level + 1);
            }

            if (node.right != null)
            {
                queue.Enqueue(node.right);
                queue.Enqueue(level + 1);
            }
        }        
    }

    public static void Main(string[] args)
    {
        AVLTree tree = new AVLTree();
        tree.Insert(19);
        tree.Insert(24);
        tree.Insert(12);
        tree.Insert(11);
        tree.Insert(17);
        tree.Insert(-4);
        tree.Insert(0);
        tree.Insert(-21);
        tree.Insert(18);
        tree.Insert(14);
        tree.Insert(7);
        tree.Insert(-6);
        tree.Insert(1);
        tree.Insert(5);
        tree.Insert(15);
        tree.Insert(9);
        tree.Insert(10);
        tree.Insert(6);
        tree.Insert(-9);
        tree.Insert(-1);
        tree.Insert(2);
        tree.Insert(20);
        tree.Insert(-19);
        tree.Insert(4);
        tree.Insert(-3);

        tree.PrintTree();
        Console.Read();
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Trie-Trees</h1>
				  <p class="lead">Trie-Trees are efficient data structures for searching for items in time proportional to its key length (such as a string). Using a Binary Search Tree would require us to use
				  M*Log(N) time where M is the length of the Key and N is the number of keys in the tree. Trie-Trees bring this value down to simply O(M), but takes up additional memory.
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Trie-Tree Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

public class TrieNode
{
    public Dictionary&ltchar, TrieNode&gt children = new Dictionary&ltchar, TrieNode&gt();
    public bool wordEnd = false;

    public TrieNode()
    {

    }
}

public class TrieTree
{
    public TrieNode root;

    public TrieTree()
    {
        root = new TrieNode();
    }

    public void Insert(string key)
    {
        TrieNode node = root;
        int length = key.Length;

        for (int level = 0; level &lt length; level++)
        {
            if (!node.children.ContainsKey(key[level]))
            {
                TrieNode newNode = new TrieNode();
                node.children.Add(key[level], newNode);
                node = newNode;
            }
            else
            {
                node = node.children[key[level]];
            }
        }
        node.wordEnd = true;
    }

    public bool Search(string key)
    {
        TrieNode node = root;
        int length = key.Length;
        
        for (int level = 0; level &lt length; level++)
        {
            if (node.children.ContainsKey(key[level]))
            {
                node = node.children[key[level]];
            }
            else
            {
                return false;
            }
        }

        return node.wordEnd;
    }

    public static void Main(string[] args)
    {
        TrieTree tree = new TrieTree();
        tree.Insert("test");
        tree.Insert("testing");
        tree.Insert("algo");
        tree.Insert("a");
        tree.Insert("algorithm");
        tree.Insert("trie");        
        
        Console.WriteLine("Should be True, result: " + tree.Search("test"));
        Console.WriteLine("Should be False, result: " + tree.Search("testi"));
        Console.WriteLine("Should be True, result: " + tree.Search("a"));
        Console.WriteLine("Should be False, result: " + tree.Search("tri"));
        Console.WriteLine("Should be False, result: " + tree.Search("tria"));
        Console.WriteLine("Should be True, result: " + tree.Search("trie"));
        Console.WriteLine("Should be False, result: " + tree.Search("algorithms"));
        Console.WriteLine("Should be True, result: " + tree.Search("testing"));
        
        Console.Read();
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Tree Traversal</h1>
				  <p class="lead">There are 4 main types of tree traverals: Inorder, Preorder, Postorder, and Level Order. Inorder, Preorder, and Postorder are all performed using a Depth First Search approach while
				  Level Order is performed using a Breadth First Search approach. You can perform Inorder, Preorder, and Postorder traversal in 3 steps with the traversal type dependant on where reading data occurs in the recursive function.
				  <ul>
					  <li>Preorder Traversal Steps: Read Root, Recursively call Preorder(left subtree), Recursively call Preorder(right subtree).</li>
					  <li>Postorder Traversal Steps: Recursively call Preorder(left subtree), Recursively call Preorder(right subtree), Read Root.</li>
					  <li>Inorder Traversal Steps: Recursively call Preorder(left subtree), Read Root, Recursively call Preorder(right subtree).</li>
					  <li>Level Order Traversal Steps: Enqueue Root, Loop till Queue empty, Read Dequeued Node, Enqueue children</li>
				  </ul>
				  </p>
				</div>
			  </div>
			</div>
			
			<br />
			
		</div>
        <!-- /#page-content-wrapper -->
				
	</div>	
	<!-- /#wrapper -->	
		
    <!-- Bootstrap core JavaScript -->
    <script src="jquery/jquery.min.js"></script>
    <script src="bootstrap/js/bootstrap.bundle.min.js"></script>

	<!-- Prism Javascript -->
	<script src="prism/prism.js"></script>
	
  </body>

</html>
