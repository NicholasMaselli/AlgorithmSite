<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Bare - Start Bootstrap Template</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">
	
	<!-- Custom styles for this template -->
    <link href="css/simple-sidebar.css" rel="stylesheet">
	
	<!-- Prism Code Stylesheet -->
	<link href="prism/prism.css" rel="stylesheet" />
	
	<!-- Custom styles -->
    <link href="css/custom.css" rel="stylesheet">

  </head>

  <body>

    <!-- Navigation -->
    <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark static-top">
      <div class="container">
        <a class="navbar-brand" href="index.html">Algorithm Site</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="about.html">About</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="contact.html">Contact</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
	
	<div id="wrapper" class="toggled">

        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li>
                    <a href="sorting.html">Sorting</a>
                </li>
                <li>
                    <a href="hashtables.html">Hash Tables</a>
                </li>
                <li>
                    <a href="trees.html">Trees</a>
                </li>
                <li>
                    <a href="graphs.html">Graphs</a>
                </li>
                <li>
                    <a href="other.html">Other Algorithms</a>
                </li>
                <li>
                    <a href="mathematics.html">Mathematics</a>
                </li>
                <li>
                    <a href="operatingsystems.html">Operating Systems</a>
                </li>
            </ul>
        </div>
        <!-- /#sidebar-wrapper -->

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid">
                <div class="jumbotron text-center">
					<h1 class="display-2"><b>Trees</b></h1>
					<p>
					This page will go over a series of Tree Algorithms. Concepts discussed will be tree construction, tree traversal, and types of trees. Types of trees
					include Binary Trees, N-ary Trees, Tri-Trees, and Red/Black Trees which are balanced binary trees. Inorder, postorder, and preorder will also be addressed.
					</p>
				</div>
            </div>

			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Types of Trees</h1>
				  <p class="lead">This section will show implementations of Binary Trees, N-ary Trees, Tri-Trees, and Red/Black Trees. 				  
				  </p>
				</div>
			  </div>
			</div>
			
			<br />
		
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Binary Trees</h1>
				  <p class="lead">Binary Trees are trees where each node has at most 2 children. A full binary tree is a binary tree where every node has either 0 or 2 children.
				  A Complete binary tree is a tree with all levels filled except the last row, which can still be filled but doesn't have to be, and all nodes are as left as
				  possible in the tree. A binary tree is said to be perfect is all all nodes not on the last level have 2 children and all leaves are on the same level. Finally,
				  a binary tree is balanced if a tree with N nodes has a height of O(Log(N)). A Binary Tree implementation is shown below.
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Binary Tree Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

public class Node&ltT&gt
{
    public T data;
    public Node&ltT&gt left;
    public Node&ltT&gt right;

    public Node(T data)
    {
        this.data = data;
        left = null;
        right = null;
    }
}

public class BinaryTree&ltT&gt
{
    public Node&ltT&gt root;

    public BinaryTree()
    {
        root = null;
    }

    public BinaryTree(T data)
    {
        root = new Node&ltT&gt(data);
    }
}

public class BinaryTreeTest
{
    public static void Main(string[] args)
    {
        int data = 10;
        BinaryTree&ltint&gt tree = new BinaryTree&ltint&gt(data);
        tree.root.left = new Node&ltint&gt(1);
        tree.root.right = new Node&ltint&gt(2);
        tree.root.left.left = new Node&ltint&gt(5);
        tree.root.left.right = new Node&ltint&gt(3);
        tree.root.right = new Node&ltint&gt(4);
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>N-ary Trees</h1>
				  <p class="lead">N-ary Trees are similar to Binary Trees except that each node can have any number of children. A very simple Nary-Tree implementation is below.
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>N-ary Tree Implementation Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

public class Node&ltT&gt
{
    public T data;
    public List&ltNode&ltT&gt&gt nodes = new List&ltNode&ltT&gt&gt();

    public Node(T data)
    {
        this.data = data;
    }
}

public class Tree&ltT&gt
{
    public Node&ltT&gt root;

    public Tree(T data)
    {
        root = new Node&ltT&gt(data);
    }
}

public class TestTree
{
    public static void Main(string[] args)
    {
        Tree&ltint&gt tree = new Tree&ltint&gt(10);
        tree.root.nodes.Add(new Node&ltint&gt(3));
        tree.root.nodes.Add(new Node&ltint&gt(4));
        tree.root.nodes.Add(new Node&ltint&gt(10));
        tree.root.nodes.Add(new Node&ltint&gt(7));
        tree.root.nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[1].nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[2].nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[3].nodes.Add(new Node&ltint&gt(17));
        tree.root.nodes[3].nodes[0].nodes.Add(new Node&ltint&gt(1));
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />

			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Object Graph Representation</h1>
				  <p class="lead">The Object Graph Representation uses instance of classes such as Node or Vertex to represent the Vertices in the graph. There are a series of ways this can be implemented. In the implementation below,
				  each vertex records the vertices it is connected to in its _neighbors Dictionary. The Dictionary's key is a Vertex and the value is the weight of the edge that connects the vertex to the vertex in the dictionary. 
				  The GraphObject class itself contains a Dictionary of Vertices for fast lookup. The vertex class can contain more information in other implementations. Adding a vertex, updating an edge, and getting an edge's value
				  are extremely fast due to the use of Dictionaries for fast lookups.
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Object Graph Representation Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

//This class used Vertex objects to represent the vertices in the graph. Additional parameters could be added to the Vertex class such as a key or values
public class GraphObject
{
    public class Vertex
    {
        private Dictionary&ltVertex, int&gt _neighbors;

        public Vertex()
        {
            _neighbors = new Dictionary&ltVertex, int&gt();
        }

        public void addNeighbor(Vertex vertex, int weight = 1)
        {
            _neighbors.Add(vertex, weight);
        }

        public void removeNeighbor(Vertex vertex)
        {
            _neighbors.Remove(vertex);
        }

        public int getEdge(Vertex dest)
        {
            return _neighbors[dest];
        }

        public Dictionary&ltVertex, int&gt getNeighbors()
        {
            return _neighbors;
        }
    }

    private int _size;
    private Dictionary&ltVertex, Vertex&gt _graph = new Dictionary&ltVertex, Vertex&gt();

    public GraphObject()
    {
    }

    public void addVertex(Vertex vertex)
    {
        _graph.Add(vertex, vertex);
        _size++;
    }

    public void setEdge(Vertex src, Vertex dest, int weight)
    {
        _graph[src].addNeighbor(dest, weight);
    }

    public int getEdge(Vertex src, Vertex dest)
    {
        return _graph[src].getEdge(dest);
    }

    public bool hasEdge(Vertex src, Vertex dest)
    {
        return _graph[src].getNeighbors().ContainsKey(dest);
    }

    public Dictionary&ltVertex, int&gt getAdjVertices(Vertex src)
    {
        return _graph[src].getNeighbors();
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />

			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Graph Algorithms</h1>
				  <p class="lead">Graphs are extremely to modern computing applications and algorthms designed to quickly travese them are essential. Below are implementations of the depth first search,
				  breadth first search, Djikstra's Shortest Path, and A* graph algorithms. The graph being used in these algorithms is pictured below. The Graph class is the GraphMatrix class form above
				  remaned to Graph.
				  </p>
				</div>
			  </div>
			  <div class="text-center">
				<img src="images/Graph.png" alt="Weighted Undirected Graph">
				<p></p>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Breadth First Search</h1>
				  <p class="lead">The Breadth First Search Algorithm is a graph traversal algorithm that searchs all nodes a set number of levels away from the source before moving onto the next level in the graph.
				  This is Level Order Traversal and its output can be shown from the printTraversal() function in the class BFS. Output: [0, 2, 3, 4, 1, 6, 8, 10, 12, 14, 11, 16, 7, 19, 5, 9, 15, 21, 17, 23, 20, 25, 18, 26, 24, 22, ]				  
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Breadth First Search Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections;
using System.Collections.Generic;

public class BFS
{
    Graph _graph;
    int _source;

    public bool[] _visited;
    public List&ltint&gt _traversalOrder = new List&ltint&gt();

    public BFS(Graph graph, int src)
    {
        _graph = graph;
        _source = src;
        _visited = new bool[graph.getSize()];

        //Breadth First Search uses a Queue from System.Collections to do level order traversal
        //Can also use a List&ltint&gt class from System.Collections.Generic which requires a few more lines of code to Dequeue
        Queue queue = new Queue();

        queue.Enqueue(_source);
        _visited[_source] = true;
        _traversalOrder.Add(_source);

        while (queue.Count != 0)
        {
            int vertex = (int)queue.Dequeue();

            //Add all adjacent vertices to queue
            List&ltint&gt adj = _graph.getAdjVertices(vertex);
            for (int i = 0; i &lt adj.Count; i++)
            {
                if (_visited[adj[i]] == false)
                {
                    queue.Enqueue(adj[i]);
                    _visited[adj[i]] = true;
                    _traversalOrder.Add(adj[i]);
                }                
            }
        }
    }

    public void PrintTraversal()
    {
        Console.Write("[");
        for (int i = 0; i &lt _traversalOrder.Count; i++)
        {
            Console.Write(_traversalOrder[i] + ", ");
        }
        Console.Write("]");        
    }
    
    public static void Main(string[] args)
    {
        //Graph From Image
        int size = 27;
        Graph graph = new Graph(size);

        //Add All Edges
        graph.setEdge(0, 2, 10);
        graph.setEdge(2, 0, 10);
        graph.setEdge(0, 3, 10);
        graph.setEdge(3, 0, 10);
        graph.setEdge(0, 4, 15);
        graph.setEdge(4, 0, 15);
        graph.setEdge(1, 2, 5);
        graph.setEdge(2, 1, 5);
        graph.setEdge(2, 3, 20);
        graph.setEdge(3, 2, 20);
        graph.setEdge(2, 6, 10);
        graph.setEdge(6, 2, 10);
        graph.setEdge(2, 8, 35);
        graph.setEdge(8, 2, 35);
        graph.setEdge(4, 8, 45);
        graph.setEdge(8, 4, 45);
        graph.setEdge(4, 10, 40);
        graph.setEdge(10, 4, 40);
        graph.setEdge(6, 12, 15);
        graph.setEdge(12, 6, 15);
        graph.setEdge(7, 12, 10);
        graph.setEdge(12, 7, 10);
        graph.setEdge(10, 11, 10);
        graph.setEdge(11, 10, 10);
        graph.setEdge(5, 11, 5);
        graph.setEdge(11, 5, 5);
        graph.setEdge(10, 16, 20);
        graph.setEdge(16, 10, 20);
        graph.setEdge(8, 14, 30);
        graph.setEdge(14, 8, 30);
        graph.setEdge(7, 14, 5);
        graph.setEdge(14, 7, 5);
        graph.setEdge(7, 17, 25);
        graph.setEdge(17, 7, 25);
        graph.setEdge(17, 18, 5);
        graph.setEdge(18, 17, 5);
        graph.setEdge(14, 19, 5);
        graph.setEdge(19, 14, 5);
        graph.setEdge(16, 9, 25);
        graph.setEdge(9, 16, 25);
        graph.setEdge(15, 16, 15);
        graph.setEdge(16, 15, 15);
        graph.setEdge(16, 21, 20);
        graph.setEdge(21, 16, 20);
        graph.setEdge(15, 19, 10);
        graph.setEdge(19, 15, 10);
        graph.setEdge(18, 22, 5);
        graph.setEdge(22, 18, 5);
        graph.setEdge(19, 23, 10);
        graph.setEdge(23, 19, 10);
        graph.setEdge(20, 21, 15);
        graph.setEdge(21, 20, 15);
        graph.setEdge(20, 23, 20);
        graph.setEdge(23, 20, 20);
        graph.setEdge(21, 25, 25);
        graph.setEdge(25, 21, 25);
        graph.setEdge(25, 24, 20);
        graph.setEdge(24, 25, 20);
        graph.setEdge(22, 26, 35);
        graph.setEdge(26, 22, 35);
        graph.setEdge(23, 26, 25);
        graph.setEdge(26, 23, 25);
        graph.setEdge(24, 26, 20);
        graph.setEdge(26, 24, 20);

        int source = 0;
        BFS bfs = new BFS(graph, source);
        bfs.PrintTraversal();
        Console.Read();

        //Output: [0, 2, 3, 4, 1, 6, 8, 10, 12, 14, 11, 16, 7, 19, 5, 9, 15, 21, 17, 23, 20, 25, 18, 26, 24, 22, ]
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Depth First Search</h1>
				  <p class="lead">The Depth First Search Algorithm is a graph traversal algorithm that searchs all nodes down the tree before moving to the next node adjacent to the source. This is Pre Order Traversal
				  and its output can be shown from the printTraversal() function in the class DFS. Output: [0, 2, 1, 3, 6, 12, 7, 14, 8, 4, 10, 11, 5, 16, 9, 15, 19, 23, 20, 21, 25, 24, 26, 22, 18, 17, ]				  
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Depth First Search Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;

public class DFS
{
    Graph _graph;
    int _source;

    bool[] _visited;
    public List&ltint&gt _traversalOrder = new List&ltint&gt();

    public DFS(Graph graph, int source)
    {
        _graph = graph;
        _source = source;
        _visited = new bool[graph.getSize()];

        _visited[source] = true;
        _traversalOrder.Add(source);

        List&ltint&gt adj = graph.getAdjVertices(source);
        for (int i = 0; i &lt adj.Count; i++)
        {
            search(adj[i]);
        }
    }

    private void search(int vertex)
    {
        if (_visited[vertex] == false)
        {
            _visited[vertex] = true;
            _traversalOrder.Add(vertex);

            List&ltint&gt adj = _graph.getAdjVertices(vertex);
            for (int i = 0; i &lt adj.Count; i++)
            {
                search(adj[i]);
            }
        }
    }

    public void PrintTraversal()
    {
        Console.Write("[");
        for (int i = 0; i &lt _traversalOrder.Count; i++)
        {
            Console.Write(_traversalOrder[i] + ", ");
        }
        Console.Write("]");
    }
    
    public static void Main(string[] args)
    {
        //Graph From Image
        int size = 27;
        Graph graph = new Graph(size);

        //Add All Edges
        graph.setEdge(0, 2, 10);
        graph.setEdge(2, 0, 10);
        graph.setEdge(0, 3, 10);
        graph.setEdge(3, 0, 10);
        graph.setEdge(0, 4, 15);
        graph.setEdge(4, 0, 15);
        graph.setEdge(1, 2, 5);
        graph.setEdge(2, 1, 5);
        graph.setEdge(2, 3, 20);
        graph.setEdge(3, 2, 20);
        graph.setEdge(2, 6, 10);
        graph.setEdge(6, 2, 10);
        graph.setEdge(2, 8, 35);
        graph.setEdge(8, 2, 35);
        graph.setEdge(4, 8, 45);
        graph.setEdge(8, 4, 45);
        graph.setEdge(4, 10, 40);
        graph.setEdge(10, 4, 40);
        graph.setEdge(6, 12, 15);
        graph.setEdge(12, 6, 15);
        graph.setEdge(7, 12, 10);
        graph.setEdge(12, 7, 10);
        graph.setEdge(10, 11, 10);
        graph.setEdge(11, 10, 10);
        graph.setEdge(5, 11, 5);
        graph.setEdge(11, 5, 5);
        graph.setEdge(10, 16, 20);
        graph.setEdge(16, 10, 20);
        graph.setEdge(8, 14, 30);
        graph.setEdge(14, 8, 30);
        graph.setEdge(7, 14, 5);
        graph.setEdge(14, 7, 5);
        graph.setEdge(7, 17, 25);
        graph.setEdge(17, 7, 25);
        graph.setEdge(17, 18, 5);
        graph.setEdge(18, 17, 5);
        graph.setEdge(14, 19, 5);
        graph.setEdge(19, 14, 5);
        graph.setEdge(16, 9, 25);
        graph.setEdge(9, 16, 25);
        graph.setEdge(15, 16, 15);
        graph.setEdge(16, 15, 15);
        graph.setEdge(16, 21, 20);
        graph.setEdge(21, 16, 20);
        graph.setEdge(15, 19, 10);
        graph.setEdge(19, 15, 10);
        graph.setEdge(18, 22, 5);
        graph.setEdge(22, 18, 5);
        graph.setEdge(19, 23, 10);
        graph.setEdge(23, 19, 10);
        graph.setEdge(20, 21, 15);
        graph.setEdge(21, 20, 15);
        graph.setEdge(20, 23, 20);
        graph.setEdge(23, 20, 20);
        graph.setEdge(21, 25, 25);
        graph.setEdge(25, 21, 25);
        graph.setEdge(25, 24, 20);
        graph.setEdge(24, 25, 20);
        graph.setEdge(22, 26, 35);
        graph.setEdge(26, 22, 35);
        graph.setEdge(23, 26, 25);
        graph.setEdge(26, 23, 25);
        graph.setEdge(24, 26, 20);
        graph.setEdge(26, 24, 20);

        int source = 0;
        DFS dfs = new DFS(graph, source);
        dfs.PrintTraversal();
        Console.Read();

        //Output: [0, 2, 1, 3, 6, 12, 7, 14, 8, 4, 10, 11, 5, 16, 9, 15, 19, 23, 20, 21, 25, 24, 26, 22, 18, 17, ]
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
			<!-- More Page Content -->
			<div class="container-fluid section">
			  <div class="row">
				<div class="col-lg-12">
				  <h1>Djikstra's Shortest Paths Algorithm</h1>
				  <p class="lead">The Depth First Search Algorithm is a graph traversal algorithm that searchs all nodes down the tree before moving to the next node adjacent to the source. This is Pre Order Traversal
				  and its output can be shown from the printTraversal() function in the class DFS. Output: [0, 2, 1, 3, 6, 12, 7, 14, 8, 4, 10, 11, 5, 16, 9, 15, 19, 23, 20, 21, 25, 24, 26, 22, 18, 17, ]				  
				  </p>
				</div>
			  </div>
			  <div class="row">
				<div class="col-lg-12">
					  <figure>
					  <figcaption>Djikstra's Shortest Paths Algorithm Using C#</figcaption>
						<pre class="text-left code-scroll"><code class="language-clike" contenteditable spellcheck="false">using System;
using System.Collections.Generic;
using Priority_Queue;

public class Djikstra
{
    Graph _graph;
    int _source;

    int _size;
    bool[] _visited;
    int[] _shortestDistance;
    int[] _shortestPaths;
    SimplePriorityQueue&ltint, int&gt _queue;

    public Djikstra(Graph graph, int source)
    {
        _graph = graph;
        _source = source;

        _size = graph.getSize();
        _visited = new bool[_size];
        _shortestDistance = new int[_size];
        _shortestPaths = new int[_size];

        for (int i = 0; i &lt _size; i++)
        {
            _shortestDistance[i] = int.MaxValue;
            _shortestPaths[i] = -1;
        }

        _queue = new SimplePriorityQueue&ltint, int&gt();
        _queue.Enqueue(_source, 0);
        _shortestDistance[_source] = 0;
        _shortestPaths[_source] = -1;

        //Use a Priority Queue for logerithmic O(Log(v)) insert and constant time get
        //Can also use a normal Queue, but MinDistance() function will be O(v) 
        while(_queue.Count != 0)
        {
            int vertex = MinDistanceVertex();
            _visited[vertex] = true;

            List&ltint&gt adj = _graph.getAdjVertices(vertex);
            for (int i = 0; i &lt adj.Count; i++)
            {

                //If this node has not been visited and the current _shortestDistance entry is less than or equal to the current _shortestDistance entry
                if (_visited[adj[i]] != true && _shortestDistance[adj[i]] &gt _shortestDistance[vertex] + graph.getEdge(vertex, adj[i]))
                {
                    _shortestDistance[adj[i]] = _shortestDistance[vertex] + graph.getEdge(vertex, adj[i]);
                    _shortestPaths[adj[i]] = vertex;
                    _queue.Enqueue(adj[i], _shortestDistance[adj[i]]);
                }
            }

        }
    }

    //MinDistance() function using the priority queue (Fibonacci Heap)
    public int MinDistanceVertex()
    {
        return _queue.Dequeue();
    }

    //Print the shortest path from the source to the input destination;
    public void PrintShortestPath(int destination)
    {
        List&ltint&gt shortestPath = new List&ltint&gt();
        shortestPath.Add(destination);

        //Get the parent vertex of the destination vertex
        int nextVertex = _shortestPaths[destination];
        while (nextVertex != -1)
        {
            shortestPath.Add(nextVertex);
            nextVertex = _shortestPaths[nextVertex];
        }

        Console.Write("[");
        for (int i = shortestPath.Count - 1; i &gt -1 ; i--)
        {
            Console.Write(shortestPath[i]);
            Console.Write("-&gt");
        }
        Console.WriteLine("]");
        Console.Write("Shortest Distance = " + _shortestDistance[destination]);
    }

    //MinDistance() function can also loop through all vertices in no Priority_Queue available. This is O(V^2) however.
    /*
    public int MinDistanceVertex()
    {
        int minIndex = -1;
        int minDistance = int.MaxValue;

        for (int i = 0; i &lt _size; i++)
        {
            if (_visited[i] == false && _shortestDistance[i] &lt= minDistance)
            {
                minDistance = _shortestDistance[i];
                minIndex = i;
            }
        }
        return minIndex;
    }
    */

    public static void Main(string[] args)
    {
        //Graph From Image
        int size = 27;
        Graph graph = new Graph(size);

        //Add All Edges
        graph.setEdge(0, 2, 10);
        graph.setEdge(2, 0, 10);
        graph.setEdge(0, 3, 10);
        graph.setEdge(3, 0, 10);
        graph.setEdge(0, 4, 15);
        graph.setEdge(4, 0, 15);
        graph.setEdge(1, 2, 5);
        graph.setEdge(2, 1, 5);
        graph.setEdge(2, 3, 20);
        graph.setEdge(3, 2, 20);
        graph.setEdge(2, 6, 10);
        graph.setEdge(6, 2, 10);
        graph.setEdge(2, 8, 35);
        graph.setEdge(8, 2, 35);
        graph.setEdge(4, 8, 45);
        graph.setEdge(8, 4, 45);
        graph.setEdge(4, 10, 40);
        graph.setEdge(10, 4, 40);
        graph.setEdge(6, 12, 15);
        graph.setEdge(12, 6, 15);
        graph.setEdge(7, 12, 10);
        graph.setEdge(12, 7, 10);
        graph.setEdge(10, 11, 10);
        graph.setEdge(11, 10, 10);
        graph.setEdge(5, 11, 5);
        graph.setEdge(11, 5, 5);
        graph.setEdge(10, 16, 20);
        graph.setEdge(16, 10, 20);
        graph.setEdge(8, 14, 30);
        graph.setEdge(14, 8, 30);
        graph.setEdge(7, 14, 5);
        graph.setEdge(14, 7, 5);
        graph.setEdge(7, 17, 25);
        graph.setEdge(17, 7, 25);
        graph.setEdge(17, 18, 5);
        graph.setEdge(18, 17, 5);
        graph.setEdge(14, 19, 5);
        graph.setEdge(19, 14, 5);
        graph.setEdge(16, 9, 25);
        graph.setEdge(9, 16, 25);
        graph.setEdge(15, 16, 15);
        graph.setEdge(16, 15, 15);
        graph.setEdge(16, 21, 20);
        graph.setEdge(21, 16, 20);
        graph.setEdge(15, 19, 10);
        graph.setEdge(19, 15, 10);
        graph.setEdge(18, 22, 5);
        graph.setEdge(22, 18, 5);
        graph.setEdge(19, 23, 10);
        graph.setEdge(23, 19, 10);
        graph.setEdge(20, 21, 15);
        graph.setEdge(21, 20, 15);
        graph.setEdge(20, 23, 20);
        graph.setEdge(23, 20, 20);
        graph.setEdge(21, 25, 25);
        graph.setEdge(25, 21, 25);
        graph.setEdge(25, 24, 20);
        graph.setEdge(24, 25, 20);
        graph.setEdge(22, 26, 35);
        graph.setEdge(26, 22, 35);
        graph.setEdge(23, 26, 25);
        graph.setEdge(26, 23, 25);
        graph.setEdge(24, 26, 20);
        graph.setEdge(26, 24, 20);

        int source = 0;
        int destination = 26;
        Djikstra djikstra = new Djikstra(graph, source);
        djikstra.PrintShortestPath(destination);
        Console.Read();

        //Output: 
        //[0-&gt2-&gt6-&gt12-&gt7-&gt14-&gt19-&gt23-&gt26-&gt]
        //Shortest Distance = 90
    }
}</code></pre>
					  </figure>
				</div>
			  </div>
			</div>
			
			<br />
			
		</div>
        <!-- /#page-content-wrapper -->
				
	</div>	
	<!-- /#wrapper -->	
		
    <!-- Bootstrap core JavaScript -->
    <script src="jquery/jquery.min.js"></script>
    <script src="bootstrap/js/bootstrap.bundle.min.js"></script>

	<!-- Prism Javascript -->
	<script src="prism/prism.js"></script>
	
  </body>

</html>
